{"name":"Schmetrics","tagline":"Clojure wrapper around Coda Hale's metrics (3.x)","body":"# schmetrics\r\n\r\n[![Build Status](https://travis-ci.org/joshrotenberg/schmetrics.svg?branch=master)](https://travis-ci.org/joshrotenberg/schmetrics)\r\n\r\nA simple Clojure wrapper around Coda Hale's metrics (3.x) library. Support for Gauges, Counters, Meters, Timers and Histograms.\r\n\r\n## Usage\r\n\r\n```clojure\r\n(ns my.thing\r\n (:require [schmetrics.counter :as counter]))\r\n\r\n(defn my-func\r\n  []\r\n  ;; do some stuff\r\n  (counter/inc :my-func-counter))\r\n\r\n(dotimes [x 123] (my-func))\r\n(let [r (counter/read :my-func-counter)]\r\n  (:count r)) ;; 123\r\n  \r\n;; ...\r\n\r\n```\r\n## Overview\r\n\r\nWith leiningen\r\n```clojure\r\n[schmetrics \"0.2.1\"]\r\n```\r\n\r\nor maven\r\n```xml\r\n<dependency>\r\n  <groupId>schmetrics</groupId>\r\n  <artifactId>schmetrics</artifactId>\r\n  <version>0.2.1</version>\r\n</dependency>\r\n```\r\n\r\n`schmetrics` is intended to be a thin Clojure wrapper atop Coda Hale's [metrics](http://metrics.codahale.com/) library for measuring the behavior of various aspects of an application. The Java APIs are fairly straightforward and can fairly easily be used directly via Clojure's interop, but this library ties them up and makes them a little more Clojure-y, managing some of the state behind the scenes and exposing only what's necessary to get the job done. Comments, bugs and patches are welcome. \r\n\r\nThis project came after a quick solo brainstorming of something useful and entertaining to write during Clojure West 2014. I've been using metrics on the Java side for a few weeks and just wanted to see how it might look in Clojure. So yeah.\r\n\r\n## Metrics\r\n\r\n`schmetrics` has a fairly regular API with a few exceptions noted inline below in the docs. You create a unique metric on the fly by calling it's specific namespaced function with a keyword or string, and then when you want to know the value of the metric, you call it's read function, which will return a map containing the metric specific values and some meta data.\r\n\r\n### Gauges\r\n\r\nGauges measure a value at a given point in time. In `schmetrics`, you are essentially creating a closure around some value that may be harder to reach later on, and you then have the ability to read its value at a later point. The metrics example shows a Gauge closing over the size of a queue in a queue manager class' constructor. Because we have functions as first class values in Clojure, this may not really need an equivalent, but its there for completeness and might be useful in other situations:\r\n\r\n```clojure\r\n(require '[schmetrics.gauge :as gauge])\r\n\r\n;; register a gauge with a unique name and a function that takes no arguments ...\r\n(gauge/register :my-gauge #(+ 1 2))\r\n\r\n;; when you read the gauge at some later point, the function will be called and it's value returned\r\n(gauge/read :my-gauge) \r\n{:value 3, ;; this was the result of our gauge function above \r\n :name :my-gauge}\r\n\r\n```\r\n\r\n### Counters\r\n\r\nA Counter ... counts. Up or down.\r\n\r\n```clojure\r\n(require '[schmetrics.counter :as counter])\r\n\r\n(counter/inc :my-counter 1)\r\n(counter/inc :my-counter 2)\r\n(counter/read :my-counter)\r\n{:count 3, \r\n :name :my-counter}\r\n(counter/dec :my-counter 1)\r\n{:count 2, \r\n :name :my-counter}\r\n```\r\n\r\n### Meters\r\n\r\nMeters measure the rate of an even over time, i.e. a load average.\r\n\r\n```clojure\r\n(require '[schmetrics.meter :as meter])\r\n(meter/mark :my-meter 2)\r\n(meter/mark :my-meter 3)\r\n(meter/mark :my-meter 2)\r\n(meter/mark :my-meter 4)\r\n(meter/read :my-meter)\r\n{:mean-rate 0.8747603265851388, \r\n :one-minute-rate 1.3520266487775938, \r\n :five-minute-rate 1.3900828722929706, \r\n :fifteen-minute-rate 1.396675908802938, \r\n :count 11, \r\n :name :my-meter}\r\n```\r\n\r\n### Histograms\r\n\r\nHistograms measure the statistical distribution in a stream of data.\r\n\r\n```clojure\r\n(require '[schmetrics.histogram :as histogram])\r\n\r\n(histogram/update :my-histogram 10)\r\n(histogram/update :my-histogram 20)\r\n(histogram/update :my-histogram 30)\r\n(histogram/update :my-histogram 40)\r\n(histogram/update :my-histogram 50)\r\n(histogram/read :my-histogram)\r\n{:75th-percentile 45.0, \r\n :99th-percentile 50.0, \r\n :stddev 15.811388300841896, \r\n :mean 30.0, \r\n :name :my-histogram, \r\n :median 30.0, \r\n :count 5, \r\n :999th-percentile 50.0, \r\n :max 50, :min 10, \r\n :98th-percentile 50.0, \r\n :95th-percentile 50.0}\r\n```\r\n\r\n### Timers\r\n\r\n```clojure\r\n(require '[schmetrics.timer :as timer])\r\n\r\n(timer/start :my-timer)\r\n(Thread/sleep 2000)\r\n(timer/stop :my-timer)\r\n2003765859 ;; returns the elapsed time since start was called\r\n(timer/read :my-timer)\r\n{:75th-percentile 2.003765859E9, \r\n :99th-percentile 2.003765859E9, \r\n :five-minute-rate 0.1750346638085895, \r\n :stddev 0.0, \r\n :mean 2.003765859E9, \r\n :one-minute-rate 0.10268342380651845, \r\n :name :my-timer, \r\n :median 2.003765859E9, \r\n :count 1, \r\n :999th-percentile 2.003765859E9, \r\n :max 2003765859, \r\n :mean-rate 0.021349204399746108, \r\n :min 2003765859, \r\n :98th-percentile 2.003765859E9, \r\n :fiteen-minute-rate 0.19130574782060583, \r\n :95th-percentile 2.003765859E9}\r\n```\r\n\r\n## Registry\r\n\r\n`schmetrics` pretty much hides the `metrics` registry from normal usage, but there are a few things you might need:\r\n\r\n```clojure\r\n(require '[schmetrics.registry :as registry]\r\n         '[schmetrics.counter :as counter])\r\n(counter/inc :my-counter 22)\r\n(counter/read :my-counter0\r\n{:count 22, :name :my-counter}\r\n(registry/remove-metric :my-counter)\r\n(counter/read :my-counter)\r\n{:count 0, :name :my-counter}\r\n;; note that since registration of a metric is implicit, remove essentially resets a metric, because the next time you call it it will\r\n;; automatically re-register\r\n(registry/get-metric-names)\r\n[:my-counter]\r\n(registery/get-metrics)\r\n{:my-counter #<Counter com.codahale.metrics.Counter@7f04eeb6>}\r\n(counter/inc :my-other-counter)\r\n(registry/get-counters)\r\n{:my-other-counter #<Counter com.codahale.metrics.Counter@733636ed>, :my-counter #<Counter com.codahale.metrics.Counter@7f04eeb6>}\r\n;; and so on for the other metric types\r\n```\r\n\r\n## JSON\r\n\r\nIt's easy enough to turn Clojure data structures into JSON, for sure, but `schmetrics` includes support for the `metrics-json` JSONification if you want it:\r\n\r\n```clojure\r\n(require '[schmetrics.counter :as counter] \r\n\t '[schmetrics.json :as json])\r\n(counter/inc :my-counter 22)\r\n(counter/read :my-counter)\r\n{:count 22, :name :my-counter}\r\n(json/as-string (counter/get-counter :my-counter))\r\n\"{\\\"count\\\":22}\"\r\n```\r\n\r\nIf you JSONify the registry itself, all of your metrics will be included:\r\n\r\n```clojure\r\n(require '[schmetrics.registry :as registry]\r\n         '[schmetrics.counter :as counter]\r\n         '[schmetrics.histogram :as histogram]\r\n\t '[schmetrics.json :as json])\r\n(counter/inc :my-counter 22)\r\n(histogram/update :my-histogram 42)\r\n(json/as-string (registry/get-registry))\r\n\"{\\\"version\\\":\\\"3.0.0\\\",\\\"gauges\\\":{},\\\"counters\\\":{\\\"my-counter\\\":{\\\"count\\\":22}},\\\"histograms\\\":{\\\"my-histogram\\\":{\\\"count\\\":1,\\\"max\\\":42,\\\"mean\\\":42.0,\\\"min\\\":42,\\\"p50\\\":42.0,\\\"p75\\\":42.0,\\\"p95\\\":42.0,\\\"p98\\\":42.0,\\\"p99\\\":42.0,\\\"p999\\\":42.0,\\\"stddev\\\":0.0}},\\\"meters\\\":{},\\\"\\\r\ntimers\\\":{}}\"\r\n```\r\n\r\n## History\r\n\r\n* Version 0.2.1 - 05/14/14 - repush with doc updates\r\n* Version 0.2.0 - 05/14/14 - updates to json api, initial health check api, add more registry functionality\r\n* Version 0.1.0 - 05/09/14 - initial version pushed to clojars\r\n\r\n## TODO\r\n\r\n* initial support for health checks is in, need to clean up and document\r\n* support multiple registries\r\n\r\n## License\r\n\r\nCopyright Â© 2014 Josh Rotenberg\r\n\r\nDistributed under the Apache License 2.0\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}